---
layout: post
title: "tao_of_parallism"
date: 2022-05-18 10:47:22 -0600
categaories: article
---
# 摘要

常规的并行算法对于关键数据结构是非常规数据结构例如图，树，集合，依赖图不是一个合适的抽象。提炼出对并行化很重要的算法属性，从数据并行中概括出的无固定形状的数据并行无处不在，依赖于算法的tao结构，并行化可能在于编译时间，解析器执行器或者优化器并行，因此统一化称为不相关的并行化技术。

# 背景

- 形状分析不行
- 静态依赖图不行，

# 算法的算子公式化

- 激活元素

- 邻居

- 顺序

## Galois set iterators

`Unordered-set iterator: foreach (e in Set S) {B(e)}`

选择的顺序是不确定的

# 三个维度 topology, activte node, operator

## topology

描述了承载计算的数据结构

高度结构化拓扑结构可以用一小部分参数描述，而非结构化的拓扑需要冗长的描述。**图的拓扑结构**是算法实现可用优化类型的重要指标； 例如，图具有高度结构化拓扑的算法可能适合静态分析和优化。

### 结构化

同构集合和多重集合——包含nodes但是no edges的图

### 半结构化

树——有结构化的不变量，但是很多树的节点和边都一样

### 无结构化

一般的图

## 激活节点

描述节点怎么激活和他们必须处理的顺序

1. 位置：拓扑驱动和数据驱动的方式。

   ​	拓扑驱动算法：激活节点由图决定，因此，**在某个活动节点上执行运算符不会导致其他节点变为活动状态**。常见的例子是迭代图的所有节点或边的算法。 

   ​	数据驱动算法：一个节点上的活动可能会导致其他节点变得活跃，因此节点**以数据相关且不可预测的方式变得活跃**。 一些示例是用于图形中最大流计算的 preflow-push 算法和用于事件驱动模拟的算法。

2. 顺序：激活节点在算法中有序但是其他无序

## operator

### morph

变形算子可以通过添加或删除节点和边来修改其邻域，也可以更新节点和边上的值。

### 局部计算

局部操作在领域中更新存在节点和边中的值，但是它不改变图的连通性。

### reader

如果运算符不以任何方式修改数据结构，则它是数据结构的读取器。

# 无定形的数据并行

当活动节点是**无序**的时，邻域约束必须确保**并行执行活动产生的输出与按某种顺序一次执行一个活动产生的输出相同**。对于已排序的活动元素，此顺序必须与活动元素上的顺序相同。

- 给定一组活动节点和活动节点的排序，无定形数据并行性是指**同时处理活动节点时产生的并行性**，这种并行性受到**邻域和排序约束**。
  - 并发操作可能会相互冲突
  - 活动可以动态创建
  - 活动可能会修改底层数据结构

## baseline：推测的并行执行

图存储在**共享内存**中，活动节点由**一定数量的线程处理**。线程从工作集中选择一个活动节点，并推测将操作符应用于该节点，根据需要调用图API执行对图的操作。

相邻区域不相交，并发图类可以使用**排它逻辑锁**：每个图元素都有一个排他锁，线程必须先获得锁然后再访问元素。**锁一直保持到活动终止**。如果由于锁已经由另一个线程拥有而无法获得锁，则会向运行时系统报告一个冲突，从而**回滚**一个冲突的活动.

锁操作完全由图类中的方法执行;此外，为了支持回滚，每个修改图的图API方法在修改前都要复制数据，就像其他使用事务内存和线程级投机的系统一样

- 如果活动元素没有排序，则该活动在操作符的应用程序完成时提交，然后释放所有获得的锁
- 如果活动元素是有序的，那么活动节点仍然可以以任何顺序处理，但是它们必须以串行顺序提交
- 如果这些活动不修改这些活动的交点上的节点和边，那么并发活动的邻域可以被允许重叠。因此，如果我们识别只读数据结构并且不锁定它们的元素，额外的并发是可能的;读写器锁是另一种解决方案。最一般的解是使用交换性条件;这允许并行执行迭代，即使它们对共享变量执行缩减操作

## 并行配置

不规则算法中无定形并行度的一个衡量标准是，对于给定的输入，在算法的每一步中，可以并行处理的活动节点的数量，假设

- 有一个无限大的处理器数量

- 一个活动需要一个时间步骤来执行
- 系统对邻域约束和排序约束有完善的知识，因此它只执行能够成功完成的活动，
- 每一步都执行一个最大的非冲突活动集合

## 探索数据结构减少开销

```
如果运算符的实现在修改邻域的任何元素之前读取其所有元素——谨慎的
A. 按顺序读a，写a，读b，写b
B. 读a，读b，写a，写b
```

**写全读后写的无序算法可以随机的执行，无需缓存更新或者对修改后的数据进行备份**，因为所有冲突都是在操作符执行的只读阶段检测到的

## 探索结构的协调调度

在基线系统中实现的调度策略可以称为**自治调度**，因为活动以不协调的方式执行，需要在线冲突**检测和回滚**才能正确执行。

如果我们确保只安排非冲突的迭代同时执行(我们称之为**协调调度的策略**)，那么投机性的开销就被消除了

所有这些策略都是基于显式或隐式地构造依赖图，但是它们是在程序编译和执行期间的不同时刻进行构造的。

![image-20220516115430059](C:\Users\lyj\AppData\Roaming\Typora\typora-user-images\image-20220516115430059.png)



在算子公式方面，依赖图的构建包括以下步骤:

(i)确定所有**活动节点**;

(ii)确定**对应活动的邻域和排序**;

(iii)创建尊重**邻域约束和排序约束**的活动的部分顺序

然后，活动可以并行执行，无需猜测，但需要适当的同步，以确保活动的部分顺序得到遵守。

> 虽然这种方法看起来很明显，但是像**事件驱动模拟**这样**有序的数据驱动算法**通常不能使用这种方法并行化:一个活动的执行可能会导致一个新节点变为活动，并且这个新活动可能比现有活动具有更高的优先级，并与现有活动发生冲突。

## 运行时协调

> 运行时协调可以用于除有序的数据驱动算法之外的所有不规则算法

### 无序数据驱动算法

通过将**依赖图**的构造与活动的执行交织在一起，这些算法可以在无需推测的情况下并行化。算法的执行是**逐轮**进行的。

在每一轮中，选择一组**不冲突的活动**并并行执行，**不需要同步**

任何新创建的活动将被推迟到下一轮，届时它们将与当前一轮中未处理的活动一起被考虑执行。

实施这一策略需要解决两个问题:

(i)我们如何**计算活动的邻域**，以及

(ii)给定一组活动及其邻域，我们**如何找到一组非冲突的活动**?

一般情况下，完全执行操作符的邻域，这可能会对全局数据结构产生副作用。如果某个活动在当前轮中没有被选择执行(因为冲突)，则必须撤销这些副作用，以便正确执行。一个解决方案是将**这些更新私有化**，就像在事务内存的某些版本中所做的那样。实际上，活动在每一轮中执行两次:一次是私有化，以确定社区，然后如果他们在当前一轮中被选择执行，那么再一次是真正的。从字面上看，这种策略并不是很有效;

在变形算法中，大多数操作符的实现都是**谨慎的**（先读后写），所以**活动的邻域可以通过部分执行来确定，直到活动开始对邻域进行修改**。如果活动在该轮中被选择执行，则执行只是从该点继续。

一旦确定了所有活动的邻域，我们就可以构建一个冲突图，其中节点代表算法中的活动节点，而边代表活动之间的冲突。可以使用ruby的随机并行算法找到一个最大的独立活动集[43]，这组活动可以在不同步的情况下并行执行。可以将此方法视为逐层构建和利用依赖图，并在级别之间使用障碍同步

### 拓扑驱动算法

活动不会创建新的活动节点，因此无序和有序算法都可以使用运行时协调来执行。

无序拓扑驱动的算法可以像上面描述的那样逐轮执行。这种方法的一种变体可以用于**有序拓扑驱动算法**。在这种情况下，我们找到**活动节点序列的最大前缀(**而不是活动节点集合的最大独立集合)，使前缀中的**所有活动节点都具有互不干扰的邻域**，并并行执行这些节点。然后可以使用剩余的活动节点后缀重复此过程。



## 及时协调

对于一些拓扑驱动的算法，依赖图不依赖于图的节点和边上的标签，纯粹是图拓扑的函数。因此，依赖图可以在**输入图给出之后、程序执行之前的运行时生成**。我们称这种策略为just-in-time coordination

对于易于**即时调度的拓扑驱动变形算法**，由于在算法执行过程中可以修改图的结构，改变邻域和依赖关系，因此对图的检查可能不够

## 编译时协调

些适合即时协调的算法具有结构化的输入图。在这种情况下，可以在编译时生成由**输入图的未知参数适当参数化**的依赖图

如果算法是**拓扑驱动的本地计算**，并且活动的邻域只是活动节点本身，忽略只读数据结构，那么**编译时协调**也可以不受拓扑的影响。在这种情况下，**活动是基本独立的**(受顺序约束)，因为每个活动都修改图的一个不相交的部分。一个典型的例子是计算图中每个节点的结果。输出是一个按节点索引的向量。每个活动读取图形的一部分，但只写入输出向量中特定于节点的部分。

# 算法的案例学习

## 变体算法

细化:细化操作通过添加**新的节点和边**使图变大，在这个过程中可能会删除一些节点和边。

粗化:粗化运算符将**节点或子图**聚集在一起，用代表集群的更小的子图替换它们

一般变形:所有**其他修改图形结构**的操作都属于这一类。

### 细化

数据驱动的优化算法通常在单个图上运行。大多数拓扑驱动的细化操作符操作两个数据结构Gi和Go;**Gi是只读的**，它的拓扑结构决定了算法中的活动节点，而**Go则根据每个活动而变化**

map-reduce:在map-reduce编程模型[13]中，**map操作对集合或多集合Si的每个元素“逐点”应用一个函数**，以生成另一个集合或多集合**So**。活动节点是Si的元素，它们可以以任何顺序进行处理。这是一个拓扑驱动的无序算法，是So的细化变体，因为元素是在执行期间递增地添加到So的。

流:像StreamIt[21]这样的语言中的流操作符是从输入流到输出流的细化变体(流是非严格序列[53])。无状态和有状态流操作符可以用序列上的无序和有序迭代表示

Prim的MST算法:大多数以自顶向下的方式构建树的算法使用细化变体。

### 粗化

边收缩、节点消除和子图收缩。

## 局部计算算法

### 拓扑驱动的局部计算算法

**活动节点和邻居都可以从网络结构中确定**，这在编译时就知道了，编译时调度可以有效的协调计算。大多数Jacobi迭代的并行实现都将网格划分为块，每个处理器负责更新一个块中的节点。这种数据分布比其他分布(如行或列循环分布)需要更少的处理器间通信。

### 数据驱动的局部计算算法

有一组**初始活动节点，执行一项活动可能导致其他节点也活动**，因此节点以一种不可预测的、数据驱动的方式活动。
